/*  Another option is to convert an FB record to encoded archive data for saving,   and to convert the archived data back to the FB record.   An advantage is that any archived objects will be, for lack of a better word,   "baked" into the archive, meaning there will be no concerns about them going stale while archived.  Here's a little demo showing the concept of archiving an FB record that contains both objects and a primitive.  Ken*/_window = 1begin enum 1_dtTextField_dtArrayField_dtColorWell_dtNumberField_loadRecordValuesBtnend enumbegin record aRecordCFStringRef dtTextColorRef    dtColorCFArrayRef  dtArrayshort       dtNumberend recordbegin globalsaRecord gRecordInfoend globalsgRecordInfo.dtText   = @"Hello, World!"gRecordInfo.dtColor  = fn ColorRedgRecordInfo.dtArray  = @[@"Alpha", @"Beta", @"Gamma", @"Delta"]gRecordInfo.dtNumber = 144void local fn RecordToArchiveCFURLRef  desktopURL = fn FileManagerURLForDirectory( NSDesktopDirectory, NSUserDomainMask )CFURLRef         url = fn URLByAppendingPathComponent( desktopURL, @"myDataOnDesktop.plist" )CFArrayRef   objects = @[gRecordInfo.dtText, gRecordInfo.dtColor, gRecordInfo.dtArray, fn NumberWithInteger( gRecordInfo.dtNumber)]CFArrayref      keys = @[@"dtText", @"dtColor", @"dtArray", @"dtNumber"]CFMutableDictionaryRef mutDict = fn MutableDictionaryWithObjectsForKeys( objects, keys )KeyedArchiverRef writeRef = fn KeyedArchiverRequiringSecureCoding( NO )KeyedArchiverEncodeObject( writeRef, mutDict, @"recordValues" )CFDataRef  writeData = fn KeyedArchiverEncodedData( writeRef )fn DataWriteToURL( writeData, url, NSDataWritingAtomic, NULL )// fn WorkspaceOpenURL( url )  // Uncomment to inspect in Xcode the archive property list containing the encoded record dataend fnvoid local fn ArchiveToRecordCFURLRef  desktopURL = fn FileManagerURLForDirectory( NSDesktopDirectory, NSUserDomainMask )CFURLRef         url = fn URLByAppendingPathComponent( desktopURL, @"myDataOnDesktop.plist" )CFDataRef recordData = fn DataWithContentsOfURL( url, NSDataReadingMappedIfSafe, NULL )KeyedUnarchiverRef readRef = fn KeyedUnarchiverForReadingFromData( recordData, NULL )KeyedUnarchiverSetRequiresSecureCoding( readRef, NO )CFMutableDictionaryRef mutDict = (CFMutableDictionaryRef)fn KeyedUnarchiverDecodeObject( readRef, @"recordValues" )KeyedUnarchiverFinishDecoding( readRef )gRecordInfo.dtText   = fn DictionaryValueForKey( mutDict, @"dtText"  )gRecordInfo.dtColor  = fn DictionaryValueForKey( mutDict, @"dtColor" )gRecordInfo.dtArray  = fn DictionaryValueForKey( mutDict, @"dtArray" )gRecordInfo.dtNumber = fn NumberIntegerValue( fn DictionaryValueForKey( mutDict, @"dtNumber" ) )end fnvoid local fn LoadRecordValuesToControlsControlSetStringValue(  _dtTextField,   gRecordInfo.dtText   )ColorWellSetColor(      _dtColorWell,   gRecordInfo.dtColor  )ControlSetStringValue(  _dtArrayField,  gRecordInfo.dtArray  )ControlSetIntegerValue( _dtNumberField, gRecordInfo.dtNumber )end fnvoid local fn BuildWindowCGRect r = fn CGRectMake( 0, 0, 160, 400 )window _window, @"Save Record", r, NSWindowStyleMaskTitled + NSWindowStyleMaskClosable + NSWindowStyleMaskMiniaturizabler = fn CGRectMake( 20, 280, 120, 100 )textlabel _dtTextField,,r,_windowControlSetAlignment( _dtTextField, NSTextAlignmentCenter )ControlSetFontWithName( _dtTextField, @"Menlo", 24.0 )TextFieldSetBordered( _dtTextField, YES )r = fn CGRectOffset( r, 0, -120 )textlabel _dtArrayField,,r,_windowControlSetAlignment( _dtArrayField, NSTextAlignmentCenter )ControlSetFontWithName( _dtArrayField, @"Menlo", 13.0 )TextFieldSetBordered( _dtArrayField, YES )r = fn CGRectMake( 20, 110, 120, 34 )colorwell _dtColorWell, YEs,,rr = fn CGRectOffset( r, 0, -50 )textlabel _dtNumberField,,r,_windowControlSetAlignment( _dtNumberField, NSTextAlignmentCenter )ControlSetFontWithName( _dtNumberField, @"Menlo", 24.0 )TextFieldSetBordered( _dtNumberField, YES )r = fn CGRectOffset( r, 0, -50 )button _loadRecordValuesBtn,,, @"Load records", rend fnvoid local fn DoDialog( ev as long, tag as long, wnd as long )select ( ev )case _btnClickselect ( tag )case _loadRecordValuesBtn : fn ArchiveToRecord : fn LoadRecordValuesToControlsend selectcase _windowWillClose : endend selectend fnon dialog fn DoDialogfn RecordToArchivefn BuildWindowHandleEvents
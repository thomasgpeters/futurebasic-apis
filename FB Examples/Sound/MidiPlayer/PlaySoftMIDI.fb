/*Based on Apple's 'PlaySoftMIDI'S.Van Voorst   {20140228}'Tom Dooley' in Key of GRevised {20140301}Revised {20211205} KS replaced "require_noerr(<b args>)" with "__Require_noErr(<args>)"*/include library "AudioUnit"include library "AudioToolbox"BeginCDeclaration// some MIDI constants:enum {kMidiMessage_ControlChange   = 0xB,kMidiMessage_ProgramChange   = 0xC,kMidiMessage_BankMSBControl  = 0,kMidiMessage_BankLSBControl  = 32,kMidiMessage_NoteOn    = 0x9};EndCBeginCCodeAUGraph graph = 0;AudioUnit synthUnit;OSStatus result;int note[26];int duration[26];UInt8 midiChannelInUse = 0; //we're using midi channel 1...//create the nodes of the graphAUNode synthNode, limiterNode, outNode;AudioComponentDescription cd;cd.componentManufacturer = kAudioUnitManufacturer_Apple;cd.componentFlags = 0;cd.componentFlagsMask = 0;result = NewAUGraph (&graph);cd.componentType = kAudioUnitType_MusicDevice;cd.componentSubType = kAudioUnitSubType_DLSSynth;result = AUGraphAddNode (graph, &cd, &synthNode);cd.componentType = kAudioUnitType_Effect;cd.componentSubType = kAudioUnitSubType_PeakLimiter;  result = AUGraphAddNode (graph, &cd, &limiterNode);cd.componentType = kAudioUnitType_Output;cd.componentSubType = kAudioUnitSubType_DefaultOutput;  result = AUGraphAddNode (graph, &cd, &outNode);result = AUGraphOpen (graph);result = AUGraphConnectNodeInput (graph, synthNode, 0, limiterNode, 0);result = AUGraphConnectNodeInput (graph, limiterNode, 0, outNode, 0);// ok we're good to go - get the Synth Unit...result = AUGraphNodeInfo(graph, synthNode, 0, &synthUnit);// ok we're set up to go - initialize and start the graph__Require_noErr(result = AUGraphInitialize (graph), home); //set our bank__Require_noErr(result = MusicDeviceMIDIEvent(synthUnit,        kMidiMessage_ControlChange << 4 | midiChannelInUse,        kMidiMessage_BankMSBControl, 0,       0/*sample offset*/), home);__Require_noErr(result = MusicDeviceMIDIEvent(synthUnit,        kMidiMessage_ProgramChange << 4 | midiChannelInUse,        0/*prog change num*/, 0,       0/*sample offset*/), home);CAShow (graph); // prints out the graph so we can see what it looks like...result = AUGraphStart (graph);// Tom Dooley in key of Gnote[0] = 62;note[1] = 62;note[2] = 62;note[3] = 64;note[4] = 67;note[5] = 71;note[6] = 71;// ========= //note[7] = 62;note[8] = 62;note[9] = 62;note[10] = 64;note[11] = 67;note[12] = 69;// ======== //note[13] = 62;note[14] = 62;note[15] = 62;note[16] = 64;note[17] = 67;note[18] = 69;note[19] = 69;// ========= //note[20] = 69;note[21] = 69;note[22] = 71;note[23] = 67;note[24] = 64;note[25] = 67;#define _eighthNote  1#define _quarterNote 2#define _halfNote 4#define _dottedHalfNote 6#define _wholeNote 8duration[0] = _eighthNote;duration[1] = _quarterNote;duration[2] = _eighthNote;duration[3] = _quarterNote;duration[4] = _quarterNote;duration[5] = _quarterNote;duration[6] = _dottedHalfNote;// =================== //duration[7] = _eighthNote;duration[8] = _quarterNote;duration[9] = _eighthNote;duration[10] = _quarterNote;duration[11] = _quarterNote;duration[12] = _wholeNote;// ================== //duration[13] = _eighthNote;duration[14] = _quarterNote;duration[15] = _eighthNote;duration[16] = _quarterNote;duration[17] = _quarterNote;duration[18] = _quarterNote;duration[19] = _dottedHalfNote;// ==================//duration[20] = _eighthNote;duration[21] = _quarterNote;duration[22] = _eighthNote;duration[23] = _quarterNote;duration[24] = _quarterNote;duration[25] = _wholeNote;// **** lower number is faster **** ////#define _tempo 1.0//#define _tempo 1.5//#define _tempo 2.0#define _tempo 2.25//#define _tempo 3.5for (int i = 0; i < 26; i++) { UInt32 noteNum = note[i]; UInt32 onVelocity = 127; UInt32 noteOnCommand =  kMidiMessage_NoteOn << 4 | midiChannelInUse; int    noteDuration = duration[i]; __Require_noErr(result = MusicDeviceMIDIEvent(synthUnit, noteOnCommand, noteNum, onVelocity, noteDuration), home);switch (noteDuration){ case 1:   nanosleep( ( struct timespec[] ) {{0,125000000*_tempo}}, NULL );   break; case 2:   nanosleep( ( struct timespec[] ) {{0,250000000*_tempo}}, NULL );   break; case 4:    nanosleep( ( struct timespec[] ) {{0,500000000*_tempo}}, NULL );    break; case 6:    nanosleep( ( struct timespec[] ) {{1,000000000*_tempo}}, NULL );    break; case 8:    nanosleep( ( struct timespec[] ) {{1,000000000*_tempo}}, NULL );    break;} result = MusicDeviceMIDIEvent(synthUnit, noteOnCommand, noteNum, 0, 0);}home:if (graph) { AUGraphStop (graph); // stop playback - AUGraphDispose will do that for us but just showing you what to do DisposeAUGraph (graph);}EndC
/*  Background Drawing 4  Bernie Wylde 20180712*/_drawingWnd = 1_controlPanel = 2begin enum 1_drawBtnend enumbegin globalsCFMutableArrayRef gPathsend globalsvoid local fn ViewDrawCFDictionaryRef   dictCFArrayRef        pathsBezierPathRef     pathColorRef          colwindow output _drawingWndif ( gPaths )// fast enumerate a 'copy' of gPaths because gPaths may still be changingpaths = fn ObjectCopy(gPaths)for dict in pathspath = fn DictionaryObjectForKey( dict, @"Path" )col = fn DictionaryObjectForKey( dict, @"Color" )ColorSet( col )BezierPathStroke( path )nextend ifend fnvoid local fn Finishedbutton _drawBtn, YES,,,,,, _controlPanelend fnvoid local fn TriggerRedrawif ( fn WindowExists(_drawingWnd) )window output _drawingWndViewSetNeedsDisplay( _windowContentViewTag )end ifend fnvoid local fn AddPath( array as CFMutableArrayRef )CGFloat   stroke, r, g, bCGPoint pt1 = {rnd(600),rnd(600)}CGPoint pt2 = {rnd(600),rnd(600)}stroke = rnd(3)BezierPathRef path = fn BezierPathInitBezierPathMoveToPoint( path, pt1 )BezierPathLineToPoint( path, pt2 )BezierPathSetLineWidth( path, stroke )r = (rnd(65536)-1)/65536.0g = (rnd(65536)-1)/65536.0b = (rnd(65536)-1)/65536.0ColorRef col = fn ColorWithRGB( r, g, b, 1.0 )MutableArrayAddObject( array, @{@"Path":path,@"Color":col} )end fnvoid local fn BackgroundFunction( array as CFMutableArrayRef )long ifor i = 0 to 200delay 15// slow things down a bit so we can see it workingfn AddPath( array )ObjectCallFunctionOnMainThread( @fn TriggerRedraw, NULL, YES )next iObjectCallFunctionOnMainThread( @fn Finished, NULL, YES )end fnvoid local fn StartDrawingbutton _drawBtn, NOgPaths = fn CFArrayCreateMutable( _kCFAllocatorDefault, 0, @kCFTypeArrayCallBacks )ObjectCallFunctionInBackground( @fn BackgroundFunction, gPaths )end fnvoid local fn BuildWindowsCGRect   rwindow _drawingWnd, @"Background Drawing", (0,0,600,600)WindowSubclassContentView(_drawingWnd)ViewSetFlipped( _windowContentViewTag, YES )r = fn WindowContentRectForFrameRect( _drawingWnd, fn WindowFrame( _drawingWnd ) )r = fn CGRectMake(r.origin.x-170,r.origin.y+r.size.height-150,150,150)panel _controlPanel, @"Control", r, NSWindowStyleMaskTitled + NSWindowStyleMaskUtilityWindowbutton _drawBtn,,, @"Draw", (40,60,70,28)ControlSetSize( _drawBtn, NSControlSizeSmall )WindowAddChildWindow( _drawingWnd, _controlPanel, NSWindowAbove )end fnvoid local fn DoDialog( ev as long, tag as long, wnd as long )select ( ev )case _btnClickselect ( wnd )case _controlPanelselect ( tag )case _drawBtn : fn StartDrawingend selectend selectcase _viewDrawRect : fn ViewDrawend selectend fnfn BuildWindowson dialog fn DoDialogHandleEvents
//==========================================================================//// Note the unconventional pointer use to pass the contextual data.// In a real program you'd want to pass a pointer to an object or structure// or some other meaningful batch of data where a pointer makes sense.// The usage shown is more ( mostly more ) or less just passing by value.//// The task work is obviously contrived. It is just the bare mechanics// and needs work before it should be used in real production code.//// N.B. Don't assume a task's submission order ( i.e. 1st, 2nd, 3rd etc. ) corresponds to its completion order.// It's possible that tasks submitted later might finsih ahead of tasks submitted earlier.// The system itself decides when to dispatch the tasks on a thread. System loading// and other factors influence the decision.//// 2022-Nov-02 Brian//// 2025-Feb-24 Brian//   Updated to show C string passing to a callback and CFStringRef passing to a callback.//   Some Errors corrected//   N.B. dispatch_group_notify_f must be called AFTER all the other tasks have been submitted//   If you put the notify first, the group will be empty and the notification block submitted immediately ( which makes the notiication useless )//==========================================================================include "Tlbx Dispatch.incl"void local fn MyMoreWorkFunction( ctx as ptr )long x = 0, y  = 0for long i = 0 to 9999999999 //  force more time in loop to simulate a longer-running function.x++ // simulate doing work inside this for/next loopy++next idispatchmainprintf @"MyMoreWorkFunction completed and passed numeric is: %d\n", ctxdispatchendend fnvoid local fn MyBriefFunction( ctx as ptr )for short i = 0 to 2 //  do some work//delay 2 // simulate a lot of worknext idispatchmainprintf @"MyBriefFunction completed and passed numeric is: %d\n", ctxdispatchendend fnvoid local fn MyPassedCStrFunction( ctx as ptr ) // C string ( ctx )  is coming in....for short i = 0 to 2 //  do some worknext i//long length = fn strlen( ctx )                                                                              // if the length of the incoming C string is needed.CFStringRef cfStr  = fn CFStringCreateWithCString( _kCFAllocatorDefault, #ctx, _kCFStringEncodingUTF8 )       // make sure it stays around. No autoreleasefree( ctx )    // done with this, so free the malloc'd spacedispatchmain//printf @"MyPassedObjectFunction completed and passed data is: %s", ctx      // using the incoming C stringprintf @"MyPassedObjectFunction completed and passed string is: %@\n", cfStr  // using CFString converted from the incoming C stringCFRelease( cfStr )                                                            // CFStringCreateWithCString() was used, so release neededdispatchendend fnvoid local fn MyPassedCFStringFunction( cfStr as CFStringRef ) // CFSstring string ( ctx )  is coming in....for short i = 0 to 2 //  do some worknext idispatchmainprintf @"MyPassedCFStringFunction completed and passed string is: %@\n", cfStr  // using incoming CFStringCFRelease( cfStr )dispatchendend fnvoid local fn AllFunctionsEnded( ctx as ptr )dispatchmainprintf @"Group Notification: All functions completed and passed data is: %d\n", ctxdispatchend// call next task since both dispatched tasks are completeend fnvoid local fn StartActionwindow 1dispatch_group_t group = fn dispatch_group_createdispatch_queue_t queue = fn dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_DEFAULT, 0 )dispatch_group_async_f( group, queue, 1001, @fn MyMoreWorkFunction )  // Start task one on a background queue and call the function when completedispatch_group_async_f( group, queue, 1002, @fn MyBriefFunction )     // Start task two on a background queue and call the function when completechar me(5) = 'Brian'long size = fn strlen( @me(0) ) + 1ptr cStrPtr = fn malloc( size )fn memMove( cStrPtr, @me(0), size )dispatch_group_async_f( group, queue, #cStrPtr, @fn MyPassedCStrFunction ) // pass a C stringCFStringRef cfStr  = fn CFStringCreateWithCString( _kCFAllocatorDefault, #cStrPtr, _kCFStringEncodingUTF8 )//cln dispatch_group_async_f( group, queue, (void *)cfStr, &MyPassedCFStringFunction ); // pass a CFStringRef but cast to void *dispatch_group_async_f( group, queue, (ptr)cfStr, @fn MyPassedCFStringFunction ) // pass a CFStringRef but cast to ptrdispatch_group_notify_f(group, queue, 9999, @fn AllFunctionsEnded )   // Notify me when both tasks have completed - IMPORTANT - always put the group-notify AFTER all the group_async callsend fnfn StartActionHandleEvents
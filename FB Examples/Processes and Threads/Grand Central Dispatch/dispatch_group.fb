/*  Group Grope - Brian 2022-Nov-23  Both dispatched tasks share a global array but each task accesses their own portion of the array.  One task utilizes the array's odd-numbered indices and the other even.     Global array won't vanish while one of the tasks works. Passing a local array from DoDialog won't  work because the array would be gone ( when DoDialog exits - which is immediately ) before the   background tasks could finish using it.A better data approach is to allocate heap storage ( malloc ) or use an object ( NSArray, Dict )  that is retained until all is done.  This is a bare-bones demo of dispatch_group using the "function" (see the suffix '_f' on some calls )  versions. Having the callback function is a little more clumsy than the block (^) Objective-C  implementations but FB doesn't support blocks/closures yet.  This passes the array via the context pointer for DoTask1 and DoTask2. I missed this change for the original post.  Making this change allows an easy departure from the global array per the possibilities mentioned in the source code notes.*/include "Tlbx Dispatch.incl"begin globalsdispatch_queue_t queuedispatch_group_t group   // keeping global so fn Finished has access for releaseshort a1(25)end globalsinclude "NSLog.incl"// This is passed a pointer to the dispatch group previously created.// In non-ARC environments this object must be released per Apple's doc.//  https://developer.apple.com/documentation/dispatch/1452951-dispatch_group_notify_f//void local fn Finished( myA1(25) as short ) //dispatchmain    // manipulate UI elements on the main threadWindowClose(1)dispatchendfor short i  = 0 to 20NSLog(@"a1(%d) contains: %d", i, myA1(i) )nextNSLog(@"\nBoth tasks done")dispatch_release( group )end fn//// Incoming parm ptrContext is passed by the dispatch_group_async_f() - third parameter// In this case NULL was sent for the context because DoTask1 doesn't need it.//void local fn DoTask1( myA1(25) as short ) // ptrContextlong ifor i = 0 to 20 step 2myA1(i) = i// NSLog is a UI update but is automatically called on the main threadNSLog(@"Task *ONE* loop work: %d",i)nextNSLog(@"Task *ONE* loop END\n\n")end fn//// Incoming parm ptrContext is passed by the dispatch_group_async_f() - third parameter// In this case NULL was sent for the context because DoTask1 doesn't need it.//void local fn DoTask2( myA1(25) as short ) // ptrContextfor long i = 1 to 20 step 2myA1(i) = iNSLog(@"Task *TWO* loop work: %d",i)nextNSLog(@"Task *TWO loop END\n\n")end fnvoid local fn BuildWindowwindow 1WindowCenter(1)button 1,,, @"Let em rip!", (213,13,125,32)end fnvoid local fn DoDialog( ev as long )if ( ev == _btnClick )queue = fn dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)group = fn dispatch_group_create()dispatch_group_async_f( group, queue, @a1(0), @fn DoTask1 )   // dispatch the first taskdispatch_group_async_f( group, queue, @a1(0), @fn DoTask2 )   // dispatch the second taskdispatch_group_notify_f(group, queue, @a1(0), @fn Finished)   // Notify me at fn Finished when BOTH tasks are completeend if//===================================================================================// don't make the mistake of trying to access your data here. It's likely one or both// of your dispatched tasks are still running. You can access them at fn Finished//===================================================================================end fnfn BuildWindowon dialog fn DoDialogHandleEvents
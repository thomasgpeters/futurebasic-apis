/*  Beachball of Death  "I think I've really nailed down the artwork"  Ken Loopinheiser*/output file "Beachball of Death"include resources "Images"_window = 1begin enum 1_startBtn_stopBtnend enumbegin globalsOperationQueueRef gQend globalsvoid local fn ResetCursorCursorSetArrowgQ = NULLwindow output _windowbutton _startBtn, 1button _stopBtn, 0end fnvoid local fn SetCursorImage( queue as OperationQueueRef, obj as CFTypeRef )long       i = fn NumberLongValue( obj )ImageRef   image = fn ImageNamed(fn StringWithFormat(@"Images/BOD%ld.png",i))ImageSetSize( image, fn CGSizeMake(100,100) )CursorSetImage( image, fn CGPointMake(54,9) )CFRelease( obj )end fnvoid local fn RotateCursorOperationQueueRef   q = fn OperationQueueCurrentCFArrayRef          operations = fn OperationQueueOperations( q )OperationRef        op = fn ArrayObjectAtIndex( operations, 0 )long i = 1doOperationQueueAddOperationWithCallback( fn OperationQueueMain, @fn SetCursorImage, fn CFRetain(@(i)) )delay 150i++if ( i > 10 ) then i = 1until ( fn OperationIsCancelled( op ) )OperationQueueAddOperationWithCallback( fn OperationQueueMain, @fn ResetCursor, NULL )end fnvoid local fn BuildWindowwindow _window, @"Beachball of Death", (0,0,550,400)button _startBtn,,, @"Start", (14,352,70,32)button _stopBtn, 0,, @"Stop", (84,352,70,32)end fnvoid local fn DoDialog( ev as long, tag as long )CFArrayRef   operationsOperationRef opif ( ev == _btnClick )select ( tag )case _startBtnbutton _startBtn, 0button _stopBtn, 1gQ = fn OperationQueueInitOperationQueueAddOperationWithCallback( gQ, @fn RotateCursor, NULL )case _stopBtnoperations = fn OperationQueueOperations( gQ )op = fn ArrayObjectAtIndex( operations, 0 )OperationCancel( op )end selectend ifend fnfn BuildWindowon dialog fn DoDialogHandleEvents
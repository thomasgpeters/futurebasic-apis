/*  Slide Puzzle v2.0  Ken Shmidheiser 20220517 Initial Demo  Bernie Wylde    20220517 Logic and Animation improvements  Ken Shmidheiser 20220519 Added timer and GUI improvements  Ken Shmidheiser 20220522 Game logic entirely rewritten  Bernie Wylde    20220522 Fade-In "You Win!" button added  Ken Shmidheiser 20220522 Tweaked GUI  Ken Shmidheiser 20220523 Added visual and sound victory effects  Showcases collection getters (in this case array getters)  first available in FB 7.0.14.*/// For shuffled array functioninclude "Tlbx GameplayKit.incl"begin globalsBOOL      gFirstMove = YESBOOL      gStoppedNSInteger gTimerCount, gEmptyCellTimerRef  gAppTimerend globals_window = 1begin enum output 1_btn1_btn2_btn3_btn4_btn5_btn6_btn7_btn8_btn9_timerField = 20_playBtnend enumvoid local fn EnableButtons( flag as BOOL )NSInteger tagfor tag = 1 to 8button tag, flagnextend fnvoid local fn BuildButtonGridNSInteger  i, cellCounterCGRect     rCFArrayRef shuffledArray/*Create grid of 9 buttons and an 9 imaginary grid cell rectsthat will be used to identify by name each grid cell. Thesegrid cell rects are stored as app properties for latercomparison with rects of each button.=============| 1 | 2 | 3 ||-----------|| 4 | 5 | 6 ||-----------|| 7 | 8 | 9 |=============*/cellCounter = 0r = fn CGRectMake( 60, 300, 85, 95 )// Create 9 buttons over an imaginary cell grid, and save their original rect positonsfor i = _btn1 to _btn9button i, YES,,, r,, NSBezelStyleShadowlessSquare, _windowButtonSetImageDimsWhenDisabled( i, NO )// Set button title fontControlSetFontWithName( i, @"Times", 60.0 )// Set button titleButtonSetTitle( i, fn StringWithFormat( @"%d", i ) )// NOTE: Only borderless buttons can be coloredButtonSetBordered( i, NO )// Set font color to goldButtonSetContentTintColor( i, fn ColorWithRGB( 0.995, 0.778, 0.223, 1.0 ) )// Color odd numbered buttons white, and even numbered redif ( i mod 2 )// Set background color of odd buttons to whileButtonSetBackgroundColor( i, fn ColorWhite )else// Change backgroud of even buttons to redButtonSetBackgroundColor( i, fn ColorRed )end if/*Each original button rect also represents the underlying invisible grid cell rect.Store the grid cell rect as an app property to later compare for empty rects andbutton locations. Key will be in the form of @"1". @"2", @"3", etc. */AppPropertySet( fn StringWithFormat( @"%ld", i ), fn ValueWithRect( r ) )// Increment column offsetr = fn CGRectOffset( r, 90, 0 )// Increment row offsetcellCounter++if cellCounter == 3 then r = fn CGRectMake( 60, 200, 85, 95 )if cellCounter == 6 then r = fn CGRectMake( 60, 100, 85, 95 )next// Shuffle array keys to locate buttons on random grid rects...shuffledArray = fn ArrayShuffledArray( @[@"1",@"2",@"3",@"4",@"5",@"6",@"7",@"8",@"9"] )// Reassign the 9 buttons to their shuffled grid cell rect locationscellCounter = 1for i = 0 to 8r = fn ValueRect( fn AppProperty( fn StringWithFormat( @"%ld", fn NumberIntegerValue( shuffledArray[i] ) ) ) )ViewSetFrame( cellCounter, r )button cellCountercellCounter++next// Only 8 play buttons are needed, so close No. 9. The rect it occupied will be the initial empty space.ButtonClose( 9 )end fnvoid local fn BuildWindowNSInteger  wndStyleMaskCGRect     rwndStyleMask  = NSWindowStyleMaskTitledwndStyleMask += NSWindowStyleMaskClosablewndStyleMask += NSWindowStyleMaskMiniaturizabler = fn CGRectMake( 0, 0, 385, 420 )window _window, @"Ken's Slide Puzzle", r, wndStyleMaskWindowSetBackgroundColor( _window, fn ColorBlack )r = fn CGRectMake( 60, 64, 264, 26 )textfield _timerField, YES, @"0:00.0", r, _windowControlSetAlignment( _timerField, NSTextAlignmentCenter )ControlSetFontWithName( _timerField, @"Arial Bold", 20.0 )TextFieldSetTextColor( _timerField, fn ColorWithRGB( 0.115, 0.540, 0.052, 1.0 ) )TextFieldSetBackgroundColor( _timerField, fn ColorBlack )TextFieldSetBordered( _timerField, NO )TextFieldSetDrawsBackground( _timerField, YES )TextFieldSetSelectable( _timerField, NO )TextFieldSetEditable( _timerField, NO )r = fn CGRectMake( 60, 30, 266, 30 )button _playBtn, YES, , @"New Game", r, NSButtonTypeMomentaryLight, NSBezelStyleRegularSquare, _window// Set button title fontControlSetFontWithName( _playBtn, @"Menlo", 16.0 )// Set button color. Only non-bordered buttons can be colored.ButtonSetBordered( _playBtn, NO )ButtonSetBackgroundColor( _playBtn, fn ColorDarkGray )ButtonSetTitleColor( _playBtn, fn ColorWhite )end fn Begin Timer Functions                                                                                |local fn CalculateTime as CFStringRefNSInteger    t, minuteQuotient, minuteRemainder, secondQuotient, secondRemainderCFStringRef  minuteString, secondString, secondRemainderStringt = gTimerCountminuteQuotient  = t / 600minuteRemainder = t mod 600secondQuotient  = minuteRemainder / 10secondRemainder = minuteRemainder mod 10minuteString = fn StringWithFormat( @"%d", minuteQuotient )secondString = fn StringWithFormat( @"%d", secondQuotient )if( secondQuotient < 10 )secondString = fn StringWithFormat( @"0%@", secondString )end ifsecondRemainderString = fn StringWithFormat( @"%d", secondRemainder )end fn = fn StringWithFormat( @"%@:%@.%@", minuteString, secondString, secondRemainderString )void local fn StopwatchgTimerCount = gTimerCount + 1ControlSetStringValue( _timerField, fn CalculateTime )end fnvoid local fn StartStopwatchTimerRef newTimerif( gStopped == YES )newTimer = fn TimerScheduledWithInterval( 0.1, @fn Stopwatch, NULL, YES )gAppTimer = newTimerTimerFire( gAppTimer )gStopped = NOelseTimerInvalidate( gAppTimer )newTimer = fn TimerScheduledWithInterval( 0.1, @fn Stopwatch, NULL, YES )gAppTimer = newTimergStopped = NOend ifend fnvoid local fn StopStopwatchif( gStopped == NO )TimerInvalidate( gAppTimer )gStopped = YESend ifend fnvoid local fn ResetStopwatchif( gStopped != YES )fn StopStopwatchend ifgTimerCount = 0ControlSetStringValue( _timerField, @"0:00.0" )gStopped = YESend fn End Timer Functions                                                                                |local fn EmptyCell as NSIntegerNSInteger i, emptyCellCGRect    r, currentRectCFMutableArrayRef mutArr// Create mutable array representing each of the 9 grid cellsmutArr = fn MutableArrayWithArray( @[@"1",@"2",@"3",@"4",@"5",@"6",@"7",@"8",@"9"] )// Iterate over each button and compare its rect with each grid cell rect. If the rects match, remove that grid cell reference from the mutable array.for i = _btn1 to _btn8currentRect = fn ViewFrame( i )r = fn ValueRect( fn AppProperty( @"1" ) ) : if fn CGRectEqualToRect( currentRect, r ) == YES then MutableArrayRemoveObject( mutArr, @"1" ) : continuer = fn ValueRect( fn AppProperty( @"2" ) ) : if fn CGRectEqualToRect( currentRect, r ) == YES then MutableArrayRemoveObject( mutArr, @"2" ) : continuer = fn ValueRect( fn AppProperty( @"3" ) ) : if fn CGRectEqualToRect( currentRect, r ) == YES then MutableArrayRemoveObject( mutArr, @"3" ) : continuer = fn ValueRect( fn AppProperty( @"4" ) ) : if fn CGRectEqualToRect( currentRect, r ) == YES then MutableArrayRemoveObject( mutArr, @"4" ) : continuer = fn ValueRect( fn AppProperty( @"5" ) ) : if fn CGRectEqualToRect( currentRect, r ) == YES then MutableArrayRemoveObject( mutArr, @"5" ) : continuer = fn ValueRect( fn AppProperty( @"6" ) ) : if fn CGRectEqualToRect( currentRect, r ) == YES then MutableArrayRemoveObject( mutArr, @"6" ) : continuer = fn ValueRect( fn AppProperty( @"7" ) ) : if fn CGRectEqualToRect( currentRect, r ) == YES then MutableArrayRemoveObject( mutArr, @"7" ) : continuer = fn ValueRect( fn AppProperty( @"8" ) ) : if fn CGRectEqualToRect( currentRect, r ) == YES then MutableArrayRemoveObject( mutArr, @"8" ) : continuer = fn ValueRect( fn AppProperty( @"9" ) ) : if fn CGRectEqualToRect( currentRect, r ) == YES then MutableArrayRemoveObject( mutArr, @"9" ) : continuenext// The last remaining value in the mutable array will be the unmatched empty cellemptyCell = fn StringIntegerValue( fn ArrayObjectAtIndex( mutArr, 0 ) )end fn = emptyCelllocal fn CheckForWin as BOOLBOOL win = NO// Compare each button rect with cell rect. If they're equal, win = YES. If not, win = NO and exit fn. NOTE: On win, cell 9 will be empty.if fn CGRectEqualToRect( fn ViewFrame( 1 ), fn ValueRect( fn AppProperty( @"1" ) ) ) == YES then win = YES : else win = NO : exit fnif fn CGRectEqualToRect( fn ViewFrame( 2 ), fn ValueRect( fn AppProperty( @"2" ) ) ) == YES then win = YES : else win = NO : exit fnif fn CGRectEqualToRect( fn ViewFrame( 3 ), fn ValueRect( fn AppProperty( @"3" ) ) ) == YES then win = YES : else win = NO : exit fnif fn CGRectEqualToRect( fn ViewFrame( 4 ), fn ValueRect( fn AppProperty( @"4" ) ) ) == YES then win = YES : else win = NO : exit fnif fn CGRectEqualToRect( fn ViewFrame( 5 ), fn ValueRect( fn AppProperty( @"5" ) ) ) == YES then win = YES : else win = NO : exit fnif fn CGRectEqualToRect( fn ViewFrame( 6 ), fn ValueRect( fn AppProperty( @"6" ) ) ) == YES then win = YES : else win = NO : exit fnif fn CGRectEqualToRect( fn ViewFrame( 7 ), fn ValueRect( fn AppProperty( @"7" ) ) ) == YES then win = YES : else win = NO : exit fnif fn CGRectEqualToRect( fn ViewFrame( 8 ), fn ValueRect( fn AppProperty( @"8" ) ) ) == YES then win = YES : else win = NO : exit fnend fn = winlocal fn CheckForMove( tag as long )CGRect     r, buttonRectNSUInteger emptyCell, buttonLocationemptyCell = fn EmptyCell// Select rect coorindates for empty cellselect emptyCellcase 1 : r = fn ValueRect( fn AppProperty( @"1" ) )case 2 : r = fn ValueRect( fn AppProperty( @"2" ) )case 3 : r = fn ValueRect( fn AppProperty( @"3" ) )case 4 : r = fn ValueRect( fn AppProperty( @"4" ) )case 5 : r = fn ValueRect( fn AppProperty( @"5" ) )case 6 : r = fn ValueRect( fn AppProperty( @"6" ) )case 7 : r = fn ValueRect( fn AppProperty( @"7" ) )case 8 : r = fn ValueRect( fn AppProperty( @"8" ) )case 9 : r = fn ValueRect( fn AppProperty( @"9" ) )end select// Find where clicked button is located on the board by comparing its rect with grid cell rectsbuttonRect = fn ViewFrame( tag )if fn CGRectEqualToRect( buttonRect, fn ValueRect( fn AppProperty( @"1" ) ) ) == YES then buttonLocation = 1if fn CGRectEqualToRect( buttonRect, fn ValueRect( fn AppProperty( @"2" ) ) ) == YES then buttonLocation = 2if fn CGRectEqualToRect( buttonRect, fn ValueRect( fn AppProperty( @"3" ) ) ) == YES then buttonLocation = 3if fn CGRectEqualToRect( buttonRect, fn ValueRect( fn AppProperty( @"4" ) ) ) == YES then buttonLocation = 4if fn CGRectEqualToRect( buttonRect, fn ValueRect( fn AppProperty( @"5" ) ) ) == YES then buttonLocation = 5if fn CGRectEqualToRect( buttonRect, fn ValueRect( fn AppProperty( @"6" ) ) ) == YES then buttonLocation = 6if fn CGRectEqualToRect( buttonRect, fn ValueRect( fn AppProperty( @"7" ) ) ) == YES then buttonLocation = 7if fn CGRectEqualToRect( buttonRect, fn ValueRect( fn AppProperty( @"8" ) ) ) == YES then buttonLocation = 8if fn CGRectEqualToRect( buttonRect, fn ValueRect( fn AppProperty( @"9" ) ) ) == YES then buttonLocation = 9// Check for cell adjacencyselect buttonLocationcase 1 : if emptyCell == 2 or emptyCell == 4                   then exit select else exit fncase 2 : if emptyCell == 1 or emptyCell == 3 or emptyCell == 5 then exit select else exit fncase 3 : if emptyCell == 2 or emptyCell == 6                   then exit select else exit fncase 4 : if emptyCell == 1 or emptyCell == 5 or emptyCell == 7 then exit select else exit fncase 5 : if emptyCell == 2 or emptyCell == 4 or emptyCell == 6 or emptyCell == 8 then exit select  else exit fncase 6 : if emptyCell == 3 or emptyCell == 5 or emptyCell == 9 then exit select else exit fncase 7 : if emptyCell == 4 or emptyCell == 8                   then exit select else exit fncase 8 : if emptyCell == 5 or emptyCell == 7 or emptyCell == 9 then exit select else exit fncase 9 : if emptyCell == 6 or emptyCell == 8                   then exit select else exit fnend select// Move clicked button to new location with animationViewSetFrame( fn ViewAnimator( tag ), r )end fn// Fade in "YOU WIN!" 9th button on winvoid local fn WinningButtonCGRect rblock double ar = fn ValueRect( fn AppProperty( @"9" ) )button _btn9, YES, , @"YOU\nWIN!", r,, NSBezelStyleShadowlessSquare, _windowViewSetAlphaValue( _btn9, 0.0 )ControlSetFontWithName( _btn9, @"Times Bold", 30.0 )ButtonSetBordered( _btn9, NO )ButtonSetContentTintColor( _btn9, fn ColorWithRGB( 0.995, 0.778, 0.223, 1.0 ) )ButtonSetBackgroundColor( _btn9, fn ColorRed )dispatchglobalfor a = 0.0 to 1.0 step 0.01dispatchmainViewSetAlphaValue( fn ViewAnimator(_btn9), a )dispatchenddelay 15nextdispatchendend fn// On win, sequentially invert color of buttons 1 through 9 with sound effect fo each buttonvoid local fn ButtonVictoryLapblock NSInteger btnblock SoundRef  clickSounddispatchglobalfor btn = 1 to 9dispatchmainif ( btn mod 2 )ButtonSetBackgroundColor( btn, fn ColorRed )elseButtonSetBackgroundColor( btn, fn ColorWhite )end ifclickSound = fn SoundNamed( @"Pop" )fn SoundPlay( clickSound )dispatchenddelay 300nextdispatchendend fnvoid local fn DoDialog( ev as long, tag as long, wnd as long )select (ev)case _btnClickselect (tag)case _btn1,_btn2,_btn3,_btn4,_btn5,_btn6,_btn7,_btn8// Start timer on first moveif ( gFirstMove == YES )fn ResetStopwatchfn StartStopwatchgFirstMove = NOgStopped = NOend iffn CheckForMove( tag )// Stop timer when game is wonif ( fn CheckForWin == YES )fn StopStopwatchgStopped = YESgFirstMove = YESfn ButtonVictoryLapfn EnableButtons( NO )fn WinningButtonend ifcase _playBtnfn StopStopwatchfn ResetStopwatchgFirstMove = YESfn BuildButtonGridfn EnableButtons( YES )end selectcase _windowWillClose : endend selectend fnon dialog fn DoDialogfn BuildWindowfn BuildButtonGridHandleEvents
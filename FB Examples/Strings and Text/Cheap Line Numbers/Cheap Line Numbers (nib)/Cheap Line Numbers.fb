/*  Cheap Line Numbers (nib)  Bernie Wylde 20230409*/include resources "dummy.txt"// menus_mFile = 1begin enum_iJumpToLine_iToggleLineNumbersend enum_mEdit = 2// windows_mainWnd = 1begin enum output 1_splitView_scrollView1_textView1_scrollView2_textView2end enum_jumpToLineWnd = 2begin enum 1_jumpToLineFldend enum// macros#define THE_FONT fn FontWithName(@"Menlo",13)#define NUM_WIDTH 40void local fn JumpToLineCFStringRef string, lineStringlong        lineNum, count, lineStart, lineEnd, ln, index = 0CFArrayRef  linesCFRange     rangeif ( window( -_mainWnd ) == 0 ) then exit fnwindow output _mainWndstring = fn TextString( _textView2 )window _jumpToLineWndlineNum = fn ControlIntegerValue(_jumpToLineFld)lines = fn StringComponentsSeparatedByCharactersInSet( string, fn CharacterSetNewlineSet )count = len(lines)if ( lineNum < 1 or lineNum > count ) then beep : exit fnwindow close _jumpToLineWndwindow _mainWndfor ln = 0 to lineNum - 2lineString = lines[ln]index += len(lineString) + 1nextStringGetLineStartEnd( string, @lineStart, @lineEnd, NULL, fn CFRangeMake(index,0) )range = fn CFRangeMake( lineStart, lineEnd-lineStart )TextScrollRangeToVisible( _textView2, range )TextViewShowFindIndicatorForRange( _textView2, range )TextSetSelectedRange( _textView2, range )end fnvoid local fn UpdateLineNumbersCFStringRef        string    = textview(_textView2)CFArrayRef         array     = fn StringComponentsSeparatedByCharactersInSet( string, fn CharacterSetNewlineSet )long               i, count  = len(array)CFMutableStringRef mutString = fn MutableStringWithCapacity(0)for i = 0 to count - 1MutableStringAppendFormat( mutString, @"%ld\n", i+1 )nextTextSetString( _textView1, mutString )CFMutableAttributedStringRef aString = fn TextViewMutableAttributedString( _textView1 )MutableAttributedStringAddAttributesInRange( aString, @{NSFontAttributeName:THE_FONT,NSForegroundColorAttributeName:fn ColorGray}, fn CFRangeMake(0,len(aString) ) )end fnvoid local fn ScrolledNotification( note as NotificationRef )ClipViewRef c1, c2CGRect      r1, r2CGPoint     pt1, pt2c1 = fn ScrollViewContentView( _scrollView1 )c2 = fn ScrollViewContentView( _scrollView2 )r1 = fn ClipViewBounds( c1 )r2 = fn ClipViewBounds( c2 )pt1 = r1.originpt2 = r2.originif ( fn ObjectIsEqual( fn NotificationObject( note ), c2 ) )pt1.y = pt2.yClipViewScrollToPoint( c1, pt1 )ScrollViewReflectScrolledClipView( _scrollView1 )elsept2.y = pt1.yClipViewScrollToPoint( c2, pt2 )ScrollViewReflectScrolledClipView( _scrollView2 )end ifend fnvoid local fn SynchronizeScrollViews( tag1 as long, tag2 as long )ClipViewRef c1, c2c1 = fn ScrollViewContentView( tag1 )c2 = fn ScrollViewContentView( tag2 )ViewSetPostsBoundsChangedNotifications( c1, YES )ViewSetPostsBoundsChangedNotifications( c2, YES )NotificationCenterAddObserver( @fn ScrolledNotification, NSViewBoundsDidChangeNotification, c1 )NotificationCenterAddObserver( @fn ScrolledNotification, NSViewBoundsDidChangeNotification, c2 )end fnvoid local fn ToggleLineNumbersCGSize size = fn SplitViewPaneSize( _splitView, 0 )if ( size.width > 0 ) then size.width = 0 else size.width = NUM_WIDTHSplitViewSetPositionOfDivider( _splitView, 0, size.width )end fnvoid local fn BuildMenunibmenu @"MainMenu"end fnvoid local fn BuildJumpToLineWindownibwindow _jumpToLineWnd, @"JumpToLineWindow"ColorRef bgColor = fn WindowBackgroundColor( _jumpToLineWnd )WindowSetLevel( _jumpToLineWnd, NSFloatingWindowLevel )WindowSetBackgroundColor( _jumpToLineWnd, fn ColorClear )WindowSetReleasedWhenClosed( _jumpToLineWnd, NO )ViewSetWantsLayer( _windowContentViewTag, YES )CALayerRef layer = fn ViewLayer( _windowContentViewTag )CALayerSetCornerRadius( layer, 10 )CALayerSetBackgroundColor( layer, bgColor )ControlSetFormat( _jumpToLineFld, @"0123456789", YES, 0, 0 )WindowMakeFirstResponder( _jumpToLineWnd, _jumpToLineFld )end fnvoid local fn BuildMainWindownibwindow _mainWnd, @"MainWindow"SplitViewSetPositionOfDivider( _splitView, 0, NUM_WIDTH )TextViewSetWordWrap( _textView2, NO )TextSetHorizontallyResizable( _textView2, NO )CFStringRef string = fn StringWithContentsOfURL( fn BundleURLForResource( fn BundleMain, @"dummy", @"txt", NULL ), NSUTF8StringEncoding, NULL )TextSetString( _textView2, string )TextSetFont( _textView2, THE_FONT )fn SynchronizeScrollViews( _scrollView1, _scrollView2 )fn UpdateLineNumbersWindowMakeFirstResponder( _mainWnd, _textView2 )end fnvoid local fn DoAppEvent( ev as long )select ( ev )case _appWillFinishLaunchingfn BuildMenufn BuildJumpToLineWindowfn BuildMainWindowcase _appShouldTerminateAfterLastWindowClosed : AppEventSetBool(YES)end selectend fnvoid local fn DoMenu( menuID as long, itemID as long )select ( menuID )case _mFileselect ( itemID )case _iJumpToLineCGRect r1 = fn WindowFrame( _mainWnd )CGRect r2 = fn WindowFrame( _jumpToLineWnd )r2.origin.x = r1.origin.x + (r1.size.width - r2.size.width)/2r2.origin.y = r1.origin.y + r1.size.height - 58window _jumpToLineWnd,, r2textfield _jumpToLineFld,, @""case _iToggleLineNumbers : fn ToggleLineNumbersend selectend selectend fnvoid local fn DoDialog( ev as long, tag as long, wnd as long, obj as CFTypeRef )select ( wnd )case _mainWndselect ( ev )case _textDidChange   : fn UpdateLineNumberscase _windowWillClose : window close _jumpToLineWndcase _splitViewDividerThickness : DialogEventSetDouble( 0 )case _splitViewShouldAdjustSizeOfSubviewif ( fn DialogEventLong == 0 ) then DialogEventSetBool(NO)end selectcase _jumpToLineWndselect ( ev )case _windowMouseDown          : WindowPerformWindowDragWithEvent( wnd, obj )case _windowCanBecomeKeyWindow : DialogEventSetBool(YES)case _windowDidResignKey       : window close wndcase _textFieldDidEndEditingselect ( tag )case _jumpToLineFld : fn JumpToLineend selectcase _controlDoCommandBySelectorif ( fn StringIsEqual( fn DialogEventString, @"cancel:" ) )window close wndDialogEventSetBool(YES)// we handledend ifend selectend selectend fnon appevent fn DoAppEventon menu fn DoMenuon dialog fn DoDialogHandleEvents
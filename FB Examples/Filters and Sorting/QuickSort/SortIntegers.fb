begin globals// this #define is here to allow a future version to sort different types in the same code. Not implemented yet. //2022-Apr-10 Brian#define SortType as long // long, unsigned long, UInt32, double, single, Str15, Str31, Str63, or Str255_nTotal     = 10 // whatever you like. 50,000 here takes 4 ms, 5,000 or fewer takes zero ms_maxDim     = _nTotal - 1 // since we are using elements 0 to n-1SortType  gData(_maxDim)end globalsQuicksort and Heapsort// Quicksorts and Heapsorts have sort time O(n log2 n) for random data. With sufficiently// large n, they tend to be the fastest methods.toolbox qsort( pointer array, unsigned long nmembers, unsigned long member_size, ptr compar )toolbox Microseconds( UnsignedWide * microCount ) // for timing// this works only if SortType is long, SInt32 or string, but is easily modified for other typeslocal fn ComparisonCallbackForQsort( ap as ptr, bp as ptr )long   result = 0if ( ap.0& > bp.0& ) then result = NSOrderedDescending  : exit fnif ( ap.0& < bp.0& ) then result = NSOrderedAscending   : exit fnend fn = resultlocal fn CheckInOrder( array(_maxDim) as SortType, n as long )long   jif ( n > 1 )for j = n - 2 to 0 step -1if ( array(j) > array(j + 1) )printprint "-----Bad Order--------"print j, array(j)print j + 1, array(j + 1)print "----------------------"stop "Bad order"elseprint array( j )end ifnextend ifend fn// fill array(0:n-1) with random integers in this caselocal modelocal fn FillArray( array(_maxDim) as SortType, n as long )long        ifor i = 0 TO n - 1array(i)  = (rnd( 32767 )*32768) + rnd( 32767 ) // big random integersnextend fn// difference between old microseconds and present; convert to millisecondslocal modelocal fn DeltaMilliSeconds( oldMS as ^UnsignedWide ) as doubleUnsignedWide  nowMSMicroseconds( nowMS )end fn = (nowMS.lo - oldMS.lo)/1000.0  // 1 millisecond = 1000 microsecondslocal fn SortandTime( array(_maxDim) as SortType, sortName as CFStringRef, nTotal as long )UnsignedWide  startMicroS // will hold start time before each sortMicroseconds( startMicroS )qsort( @array(0), nTotal, sizeof( SortType ), @fn ComparisonCallbackForQsort )double elapsed = fn DeltaMilliSeconds( startMicroS ) // elapsed time in millisecondsprintf @"%@ sorted the array in %.0f milliseconds", sortName, elapsedprint: print "Integers in Array are: " :printfn CheckInOrder ( gData(0), nTotal )end fn// Mainwindow 1, @"Integer Sort Timing", (0,0) - (550, 250)printf @"System quicksort for %ld integers",_nTotalprintfn FillArray( gData(0), _nTotal )fn SortandTime( gData(0), @"'qsort'", _nTotal ) // pass array by reference even though it's global to minimize direct global accessprint : print "Finished"HandleEvents
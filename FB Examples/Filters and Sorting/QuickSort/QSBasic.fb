begin globals_nTotal     = 10 // whatever you like. 50,000 here takes 4 ms, 5,000 or fewer takes zero ms_maxDim     = _nTotal - 1 // since we are using elements 0 to n-1long  gData(_maxDim)end globals// Quicksorts and Heapsorts have sort time O(n log2 n) for random data. With sufficiently// large n, they tend to be the fastest methods.toolbox qsort( pointer array, unsigned long nmembers, unsigned long member_size, ptr compar )// this works only if SortType is long, SInt32 or string, but is easily modified for other typeslocal fn ComparisonCallbackForQsort( ap as ptr, bp as ptr )long   result = 0if ( ap.0& > bp.0& ) then result = NSOrderedDescending  : exit fnif ( ap.0& < bp.0& ) then result = NSOrderedAscending   : exit fnend fn = result// fill array(0:n-1) with random integers in this caselocal fn FillArray( array(_maxDim) as long, n as long )long        ifor i = 0 TO n - 1array(i)  = (rnd( 32767 )*32768) + rnd( 32767 ) // big random integersnextend fn// Mainwindow 1, @"Integer Sort", (0,0) - (550, 250)printf @"System quicksort for %ld integers",_nTotalprintfn FillArray( gData(0), _nTotal )qsort( @gData(0), _nTotal, sizeof( long ), @fn ComparisonCallbackForQsort )printf @"Highest number is %ld", gData( _nTotal - 1 )print : print "Finished"HandleEvents
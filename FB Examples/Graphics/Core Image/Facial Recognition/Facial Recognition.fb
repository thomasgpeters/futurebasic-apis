/*  Facial Recognition  Open a photo that contains one or more  forward-facing human faces, and this  demo will attempt to highlight the  face, eyes and mouth, and create a  thumbnail of the face.  Note: Results are poorer with visible  faces that are not fully forward facing.  Larger images work best.  Building the app on an M1 Mac, set Architecture  to "Apple Silicon" or "Universal". Building on M1  with Architecture set to "Intel" fails.  Dependency: CoreImage CIDetector,  CIImage and CIFaceFeatures  17 May 2021 Ken Shmidheiser  18 May 2021 Bernie Wylde    : resolved image display issue in TextView,  general clean-up, new CIImage to ImageRef  conversion function, several fixes.  18 May 2021 Ken Shmidheiser : new features, view constraints fixed.*/include "Tlbx CoreImage.incl"begin enum 1_mFile_mEditend enum_window = 1begin enum output 1_originalImageView_scrollView_imageTextView_openBtnend enumvoid local fn BuildMenumenu _mFile, -1,, @"File"editmenu _mEditend fnvoid local fn BuildWindowCGRect r = ( 0, 0, 930, 700 )window _window, @"Facial Recognition", rWindowSetContentMinSize( _window, fn CGSizeMake( 930, 360 ) )r = fn CGRectMake( 20, 60, 750, 620 )imageview _originalImageView, YES,, r, NSImageScaleProportionallyDown, NSImageAlignCenter, NSImageFramePhotoViewSetAutoresizingMask( _originalImageView, NSViewWidthSizable + NSViewHeightSizable )r = fn CGRectMake( 780, 60, 130, 620 )scrollview _scrollView, r, NSBezelBorderViewSetAutoresizingMask( _scrollView, NSViewMinXMargin + NSViewHeightSizable )textview _imageTextView,, _scrollViewTextViewSetUsesAdaptiveColorMappingForDarkAppearance( _imageTextView, YES )r = fn CGRectMake( 740, 15, 175, 28 )button _openBtn, YES, , @"Open image with faces", r, NSButtonTypeMomentaryLight, NSBezelStyleRegularSquareViewSetAutoresizingMask( _openBtn, NSViewMinXMargin + NSViewMaxYMargin )end fnlocal fn ImageRefToCIImage( image as ImageRef ) as CIImageRefCFDataRef dta = fn ImageTIFFRepresentationUsingCompression( image, NSTIFFCompressionNone, 0.0 )end fn = fn CIImageWithData( dta )void local fn AddThumbnailImage( ciImage as CIImageRef, infoStr as CFStringRef )BitmapImageRepRef imageRep = fn BitmapImageRepWithCIImage( ciImage )ImageRef image = fn ImageWithSize( fn ImageRepSize( imageRep ) )ImageAddRepresentation( image, imageRep )CGSize size = fn ImageSize( image )CGFloat w = 100CGFloat h = w/size.width * size.heightImageSetSize( image, fn CGSizeMake(w,h) )TextAttachmentCellRef cell = fn TextAttachmentCellWithImage( image )TextAttachmentRef attachment = fn TextAttachmentInitTextAttachmentSetCell( attachment, cell )CFAttributedStringRef attachmentString = fn AttributedStringWithAttachment( attachment )CFMutableAttributedStringRef aString = fn TextViewMutableAttributedString( _imageTextView )MutableAttributedStringAppendAttributedString( aString, attachmentString )MutableAttributedStringAppendCharacters( aString, fn StringWithFormat( @"\n%@\n\n", infoStr ) )end fnlocal fn FindFacesInPhoto( image as imageRef ) as ImageRefCIFaceFeatureRef faceCIImageRef       croppedImageCIImageRef       ciImage      = fn ImageRefToCIImage( image )CFDictionaryRef  options      = @{ CIDetectorAccuracy: CIDetectorAccuracyHigh }CIDetectorRef    faceDetector = fn CIDetectorOfType( CIDetectorTypeFace, NULL, options )CFDictionaryRef  faceOptions  = @{ CIDetectorSmile: @(YES) }CFArrayRef       faces        = fn CIDetectorFeaturesInImageWithOptions( faceDetector, ciImage, faceOptions )CGRect           r            = fn CIImageExtent( ciImage )CGSize           size         = fn CGSizeMake( r.size.width, r.size.height )ImageRef         drawImage    = fn ImageWithSize( size )ImageAddRepresentation( drawImage, fn CIImageRepWithCIImage( ciImage ) )ImageLockFocus( drawImage )TextSetString( _imageTextView, @"\n" )for face in facesCGRect bounds  = fn CIFaceFeatureBounds( face )BezierPathStrokeFillRect( bounds, 2.0, fn ColorWhite, fn ColorClear )croppedImage   = fn CIImageByCroppingToRect( ciImage, bounds )CFStringRef smileStrif ( fn CIFaceFeatureHasSmile( face ) )smileStr = @"Smiling\n"elsesmileStr = @"Natural\n"end ifCFStringRef faceAngleStr = @""if ( fn CIFaceFeatureHasFaceAngle( face ) )faceAngleStr = fn StringWithFormat( @"Face angle:\n%.3f degrees\n", fn CIFaceFeatureFaceAngle( face ) )end iffn AddThumbnailImage( croppedImage, fn StringWithFormat( @"%@%@", smileStr, faceAngleStr ) )if ( fn CIFaceFeatureHasLeftEyePosition( face ) )CGPoint leftEyePosition = fn CIFaceFeatureLeftEyePosition( face )CGRect leftEyeRect      = fn CGRectMake( leftEyePosition.x - 10.0, leftEyePosition.y - 10.0, 20.0, 20.0 )BezierPathStrokeFillRect( leftEyeRect, 1.0, fn ColorRed, fn ColorClear )end ifif ( fn CIFaceFeatureHasRightEyePosition( face ) )CGPoint rightEyePosition = fn CIFaceFeatureRightEyePosition( face )CGRect righEyeRect       = fn CGRectMake( rightEyePosition.x - 10.0, rightEyePosition.y - 10.0, 20.0, 20.0 )BezierPathStrokeFillRect( righEyeRect, 1.0, fn ColorRed, fn ColorClear )end ifif ( fn CIFaceFeatureHasMouthPosition( face ) )CGPoint mouthPosition = fn CIFaceFeatureMouthPosition( face )CGRect mouthRect      = fn CGRectMake( mouthPosition.x - 10.0, mouthPosition.y - 10.0, 20.0, 20.0 )BezierPathStrokeFillRect( mouthRect, 1.5, fn ColorYellow, fn ColorClear )end ifnextImageUnlockFocus( drawImage )CFMutableAttributedStringRef aString = fn TextViewMutableAttributedString( _imageTextView )TextViewSetAlignment( _imageTextView, NSTextAlignmentCenter, fn CFRangeMake( 0, len(aString) ) )end fn = drawImagevoid local fn ProcessImage( image as ImageRef )ImageRef faces = fn FindFacesInPhoto( image )ImageViewSetImage( _originalImageView, faces )end fnvoid local fn OpenImageFileImageRef imageCFURLRef urlurl = openpanel 1, @"Select an image with faces for facial recognition.", @"public.image", @"Open image with faces"if ( url )image = fn ImageByReferencingURL( url )fn ProcessImage( image )else// User canceledend ifend fnvoid local fn DoDialog( ev as long, tag as long )select (ev)case _btnClickselect (tag)case _openBtn : fn OpenImageFileend selectcase _windowWillClose : endend selectend fnon dialog fn DoDialogfn BuildMenufn BuildWindowHandleEvents
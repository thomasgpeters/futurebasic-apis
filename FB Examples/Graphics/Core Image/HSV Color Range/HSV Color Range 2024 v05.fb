/*HSV Color Range DemoThe Core Imqge CIColorCube filter -- which is key to creating a chromakey green screen applicationrequires HSV (Hue, Saturation, Value) colors rather than ColorRefs. The HSV model represents color in three dimensions.In these models, colors of each hue are arranged in a radial slice, around a central axis of neutral colorswhich range from black at the bottom to white at the top. The model is shaped like an inverted cone with theflat top looking like a standard, fully-saturated RGB color wheel with a white dot inthe center where the colors converge, tapering down to the black at the iverted cone's point.In FB's CocoaUI, the Color header contains funtions to convert ColorRefs to and from HSB (Hue, Saturating, Brightness)colors which can be used to represent HSV colors in two diemnsions. A green screen chromakey is used to eliminate green backgrounds behind an object. It does this by reducing the greencolor's alpha value to 0 giving the subject a transparent background. The subject can then be overlaid onto anotherbackground. An example is the typical television weather report where the weather forecaster stands before a greenscreen, the green background is eliminated and his/her image is superimposed on a weather map. A problem is that thefilter will make any shade of green in the image transparent, so if the forecaster is wearing a green shirt or blouse, itwill become tranparent along with the background.In programming a green screen chromakey demo in FB, I created this utility to allow me to visulaize how HSV hue angleand destination angles work. The demo opens with values set to eliminate standard green screen hues (minimum hue anglevalue of 0.30 and maximum hue angle value of 0.40.Note that backgrounds of other colors can also be removed by changing the HSV values. However, green is the standardbecause it does not intefere with human skin tones that contain red.This demo does contain a bug that allows it to display converted minimum and maximum hue values outside the 0 to 1range. But it does offer a rough visual approximation of what hues of color will be removed from an image.Ken Shmidheiser5 February 20204 September 2024 â€” Rewritten and updated KS*/include "Tlbx CoreImage.incl"output file "HSV Color Range"include resources "color_wheel.jpg"_window = 1begin enum output 1_originalImageView_colorWheelImageView_centerHueAngleSlider_centerHueValueField_colorAngleLabel_degreesSeparationSlider_degreesSeparationValue_degresSeparationLabel_angleValues_informationBtnend enumvoid local fn BuildWindowNSInteger     wndStyleMaskwndStyleMask  = NSWindowStyleMaskTitledwndStyleMask += NSWindowStyleMaskClosablewndStyleMask += NSWindowStyleMaskMiniaturizableCGRect r = fn CGRectMake( 0, 0, 1075, 430 )window _window, @"HSV Color Range", r, wndStyleMaskr = fn CGRectMake( 10, 10, 400, 400 )imageview _originalImageView, YES, @"color_wheel.jpg", r, NSImageScaleAxesIndependently, NSImageAlignCenter, NSImageFramePhoto, _windowr = fn CGRectMake( 420, 10, 400, 400 )imageview _colorWheelImageView, YES,, r, NSImageScaleAxesIndependently, NSImageAlignCenter, NSImageFramePhoto, _windowr = fn CGRectMake( 858, 30, 20, 350 )slider _centerHueAngleSlider, YES, 108, r, 0, 360, NO, _windowControlSetContinuous( _centerHueAngleSlider, YES )r = fn CGRectMake( 838, 10, 50, 16 )textlabel _centerHueValueField, @"108", r, _windowControlSetAlignment( _centerHueValueField, NSTextAlignmentCenter )r = fn CGRectMake( 836, 382, 60, 35 )textlabel _colorAngleLabel, @"Color Angle\u00B0", r, _windowControlSetAlignment( _colorAngleLabel, NSTextAlignmentCenter )r = fn CGRectMake( 908, 30, 20, 350 )slider _degreesSeparationSlider, YES, 144, r, 0, 360, NO, _windowControlSetContinuous( _degreesSeparationSlider, YES )r = fn CGRectMake( 890, 10, 50, 16 )textlabel _degreesSeparationValue, @"144", r, _windowControlSetAlignment( _degreesSeparationValue, NSTextAlignmentCenter )r = fn CGRectMake( 885, 382, 70, 35 )textlabel _degresSeparationLabel, @"Degrees Range", r, _windowControlSetAlignment( _degresSeparationLabel, NSTextAlignmentCenter )r = fn CGRectMake( 965, 250, 90, 165 )textfield _angleValues, YES, , r, _windowTextFieldSetBezelStyle( _angleValues, NSTextFieldSquareBezel )TextFieldSetEditable( _angleValues, NO )TextFieldSetSelectable( _angleValues, NO )r = fn CGRectMake( 950, 10, 115, 28 )button _informationBtn,,,@"Chroma Info", rend fnlocal fn ImageRefToCIImage( image as ImageRef ) as CIImageRefCFDataRef      dta = fn ImageTIFFRepresentationUsingCompression( image, NSTIFFCompressionNone, 0.0 )CIImageRef ciImage = fn CIImageWithData( dta )end fn = ciImagelocal fn CIImageToImageRef( ciImage as CIImageRef ) as ImageRefCIImageRepRef rep = fn CIImageRepWithCIImage( ciImage )CGSize       size = fn ImageRepSize( rep )ImageRef    image = fn ImageWithSize( size )ImageAddRepresentation( image, rep )end fn = image// Get hue functionlocal fn GetHueWithRed( red as CGFloat, green as CGFloat, blue as CGFloat ) as CGFloatColorRef color = fn ColorWithRGB( red, green, blue, 1.0 )CGFloat hue = 0hue = fn ColorHueComponent( color )end fn = hue// Create a custom ChromaKey CIFilterlocal fn ChromaKeyFilterFromHue( centerHueAngle as CGFloat, degreeRange as CGFloat ) as CIFilterRefNSInteger size = 64NSInteger x, y, zCFMutableDataRef  cubeData = fn MutableDataNewCFStringRef hueAnglesStr =  fn StringWithFormat( @"Min. Hue Angle:\n%0.f\u00B0\n%.2f\n\nMax. Hue Angle:\n%0.f\n%.2f", centerHueAngle * 360, centerHueAngle, degreeRange * 360, degreeRange )ControlSetStringValue( _angleValues, hueAnglesStr )for z = 0 to size - 1CGFloat blue = (CGFloat)z / (CGFloat)(size - 1)for y = 0 to size - 1CGFloat green = (CGFloat)y / (CGFloat)(size - 1)for x = 0 to size - 1CGFloat red = (CGFloat)x / (CGFloat)(size - 1)CGFloat hue = fn GetHueWithRed( red, green, blue )float alpha = ( hue >= centerHueAngle && hue <= degreeRange ) ? 0 : 1float premultipliedRed   = red   * alphafloat premultipliedGreen = green * alphafloat premultipliedBlue  = blue  * alphaMutableDataAppendBytes( cubeData, @premultipliedRed,   sizeof(float) )MutableDataAppendBytes( cubeData, @premultipliedGreen, sizeof(float) )MutableDataAppendBytes( cubeData, @premultipliedBlue,  sizeof(float) )MutableDataAppendBytes( cubeData, @alpha,              sizeof(float) )nextnextnextCIFilterRef chromaKeyFilter = fn CIFilterWithName( @"CIColorCube"      )ObjectSetValueForkey( chromaKeyFilter,  @(size), @"inputCubeDimension" )ObjectSetValueForkey( chromaKeyFilter, cubeData, @"inputCubeData"      )end fn = chromaKeyFilter// Apply custom Chroma Key CIFilterlocal fn RemoveColorFromSource( foregroundCIImage as CIImageRef, startRange as CGFloat, endRange as CGFloat ) as CIImageRefCIFilterRef chromaCIFilter = fn ChromaKeyFilterFromHue( startRange, endRange )ObjectSetValueForkey( chromaCIFilter, foregroundCIImage, kCIInputImageKey )CIImageRef ciImage = fn CIFilterOutputImage( chromaCIFilter )end fn = ciImagevoid local fn BuildColorDeleteImageImageRef foregroundImage = fn ImageNamed( @"color_wheel.jpg" )ImageViewSetImage( _originalImageView, foregroundImage )/*0.30, 0.40 filters out green screen0.00, 0.00 fllters out white screen0.51, 0.68 filters out blue screenGreen screens are preferred since they don't affect human skin tones.For formula to determine other color-filter values see:https://developer.apple.com/documentation/coreimage/applying_a_chroma_key_effect?language=objc*/CIImageRef      ciForeground = fn ImageRefToCIImage( foregroundImage )double        centerHueAngle = fn ControlIntegerValue( _centerHueAngleSlider    ) / 360.0double           degreeRange = fn ControlIntegerValue( _degreesSeparationSlider ) / 360.0CIImageRef ciFixedForeground = fn RemoveColorFromSource( ciForeground, centerHueAngle, degreeRange )ImageRef   colorDeletedImage = fn CIImageToImageRef( ciFixedForeground )ImageViewSetImage( _colorWheelImageView, colorDeletedImage )end fnvoid local fn DoDialog( ev as long, tag as long, wnd as long, obj as CFTypeRef )select (ev)case _btnClickselect (tag )case _centerHueAngleSliderfn BuildColorDeleteImageint centerAngle = fn ControlIntegerValue( tag )ControlSetIntegerValue( _centerHueValueField, centerAngle )case _degreesSeparationSliderfn BuildColorDeleteImageint degreeRange = fn ControlIntegerValue( tag )ControlSetIntegerValue( _degreesSeparationValue, degreeRange )case _informationBtnCFURLRef url = fn URLWithString( @"https://developer.apple.com/documentation/coreimage/applying_a_chroma_key_effect?language=objc" )fn WorkspaceOpenURL( url )end selectcase _windowWillClose : endend selectend fnon dialog fn DoDialogfn BuildWindowfn BuildColorDeleteImageHandleEvents